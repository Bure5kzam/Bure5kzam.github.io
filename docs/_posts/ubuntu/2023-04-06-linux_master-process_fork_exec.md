---
title: 우분투 fork와 exec
category : ubuntu
author: Bure5kzam
tags: [linux, process]
summary : 리눅스 프로세스 관련 시스템콜인 fork와 exec를 설명합니다.
published : false
---

# fork 와 exec

리눅스의 프로세스 관련 시스템콜인 fork와 exec의 매뉴얼을 해석한 글입니다.

## fork 

fork는 자신을 호출한 프로세스를 복제하여 새 프로세스를 생성하는 시스템 콜입니다.

fork로 새로 생성된 프로세스는 `child process`라고 합니다. fork를 호출한 프로세스는 `parent process`라고 합니다.p

두 프로세스는 같은 메모리 공간에서 실행됩니다. fork가 실행되는 순간, 두 프로세스의  메모리 공간은 같은 컨텐츠를 갖고 있습니다. 하지만 프로세스 내에서 이뤄지는 메모리 쓰기, 파일 매핑, 파일 언매핑은 다른 프로세스에 영향을 주지 않습니다.

자식 프로세스는 아래 항목을 제외하고 부모 프로세스를 정확히 복제합니다.

- 자식은 고유한 PID를 갖습니다. 이 PID는 프로세스 그룹 아이디나 세션과 다릅니다.
- 자식의 부모 프로세스 아이디(PPID)는 부모의 프로세스 아이디 (PID)로 지정됩니다.
- 자식은 부모의 메모리 락을 복사하지 않습니다. 
  - 메모리락 : 프로세스의 가상 주소 공간을 RAM에 잠금으로 써 보조 디스크에 페이징 되는것을 방지
- 자식의 프로세스 리소스 사용률과 CPU 시간 카운터는 0으로 지정됩니다.
  - CPU 시간 카운터 : 프로세스에서 사용된 여러 시간들. 
    - 예시로 프로세스에서 지시문을 실행하는데 소비한 시간 등이 있음.
- 부모에서 보류중이던 시그널들은 자식에 상속되지 않습니다.
- 자식은 세마포어를 상속하지 않습니다.
- 자식은 `process-associated record lock`을 상속받지 않습니다. (하지만 열린 파일 디스크립션 락이나 락은 상속합니다.)
- 자식은 부모의 타이머를 상속하지 않습니다.
- 자식은 부모의 비동기 I/O 연산이나 비동기 I/O 컨텍스트를 상속받지 않습니다.

앞의 프로세스 속성들은 posix.1 에서 지정되었습니다. 부모와 자식은 다음의 리눅스 프로세스 속성 관점에서도 다릅니다.

- 자식은 디렉토리 변경 알림을 상속하지 않습니다. 
- PR_SET_PDEATHSIG 세팅이 리셋되어 부모가 종료되어도 시그널을 받지 않습니다.
- 기본 타이머 슬랙 값은 부모의 현재 타이머 슬랙 값으로 지정됩니다.
- MADV_DONTFORK 플래그로 표시된 메모리 매핑은 fork로 상속되지 않습니다.
- MADV_WIPEONFORK 플래그로 표시된 주소 범위 메모리는 fork 된 후 0이 됩니다. (MADV_WIPEONFORK 설정은 자식의 해당 주소 범위에 대해 그대로 유지됩니다)
- 자식의 종료 시그널은 항상 SIGCHLD입니다.
- ioperm으로 설정된 포트 엑세스 권한 비트는 상속되지 않습니다. 자식은 ioperm 으로 필요한 비트를 모두 켜야합니다.

추가 사항

- 자식 프로세스는 fork를 호출한 싱글 쓰레드로 생성됩니다. 뮤텍스 상태, 조건 변수, 다른 pthread 객체를 포함한 부모의 전체 가상 주소 공간은 자식으로 복사됩니다. 
- 멀티 쓰레드 프로그램에서는 fork 후 자식은 execve를 실행할 때까지 오직 async-signal-safe function 만 안전하게 호출할 수 있습니다.
- 자식은 부모의 열린 파일 디스크립터 집합의 복사본을 상속받습니다. 자식의 각 파일 설명자는 동일한 파일 디스크립션을 참조합니다.



## exec

execve는 호출 프로세스의 텍스트, 데이터, bss, 스택을 로드된 프로그램으로 덮어씁니다.

현재 프로그램이 추적 중인 경우 호출 후에 SIGTRAP이 전송됩니다.

호출된 프로그램에 set-user-ID가 설정된 경우와 수행되는 파일 시스템이 nosuid로 마운트되지 않았을 경우와 호출하는 프로세스가 미리 정해지지 않았을 경우, 호출 프로하는 프로세스의 euid가 프로그램 파일의 소유자의 euid로 변경됩니다. (guid 동일)

execve가 실행되면 프로세스 euid는 saved-set-user-ID에 복사됩니다 (egid 동일). 이 복사는 set-user-ID 권한 비트로 발생하는 euid 변경 후에 발생합니다.

<!-- 만약 실행가능한 파일이 'shared-library stubs`를 포함하는 동적으로 링크된 a.out 이라면, 실행 초반에 리눅스 다이나믹 링커 (ld.so)가 호출되어 필요한 shared libararies들을 메모리에 가져오고 실행파일과 링크합니다. -->

execve를 호출한 프로세스는 아래 속성이 변합니다.

- 잡히고 있는 모든 시그널들의 배치가 기본 시그널로 리셋됩니다.
- 모든 다른 시그널 스택들은 보존되지 않습니다.
- 메모리 매핑이 보존되지 않습니다.
- 부착된 SYSTEM V 공유 메모리 세그먼트들이 탈착됩니다.
- POSIX 공유 메모리 영역이 언매핑됩니다.
- 열린 POSIX 메세지 큐 디스크립터가 닫힙니다.
- 세마포어로 명명된 모든 열린 POSIX 들이 종료됩니다.
- POSIX 타이머들이 보존되지 않습니다.
- 모든 열린 디렉토리 스트림들이 닫힙니다.
- 메모리 락이 보존되지 않습니다.
- 종료 핸들러가 보존되지 않습니다.
- 부동 소수점 환경이 기본 값으로 재설정됩니다.

선행 목록에 있는 프로세스들의 속성들은 POSIX.1-2001.에 지정되어있습니다. 리눅스에서 지정된 프로세스 속성들도 보존되지 않을 수 있습니다.

- set-user-ID나 set-group-id가 실행되고 있지 않고 PR_SET_DUMPABLE 플래그가 설정되어있으면 해제됩니다.
- prctl PR_SET_KEEPCAPS 플래그가 지워집니다.

...